第 5 章  运输层

运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。运输层为相互通信的应用进程提供了逻辑通信（网络层提供的是主机之间的逻辑通信）。

当运输层采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条全双工的可靠信道。

当运输层采用无连接的 UDP 协议时，这种逻辑通信信道是一条不可靠信道。

 

TCP 的端口

端口用一个 16 位端口号进行标志。

端口号只具有本地意义，即端口号只是为了标志本计算机应用层中的各进程。

 

三类端口

1.熟知端口，数值一般为 0~1023。

2.登记端口号，数值为1024~49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。

3.客户端口号或短暂端口号，数值为49152~65535，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。

 

用户数据报协议 UDP

UDP 只在 IP 的数据报服务之上增加了很少一点的功能，即端口的功能和差错检测的功能。虽然 UDP 用户数据报只能提供不可靠的交付，但 UDP 在某些方面有其特殊的优点。

 

UDP 的主要特点

1.UDP 是无连接的，即发送数据之前不需要建立连接。

2.UDP 使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制。

3.UDP 是面向报文的。UDP 没有拥塞控制，很适合多媒体通信的要求。

4.UDP 支持一对一、一对多、多对一和多对多的交互通信。

5.UDP 的首部开销小，只有 8 个字节。

 

UDP 是面向报文的

发送方 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。

应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。

接收方 UDP 对 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动地交付上层的应用进程，一次交付一个完整的报文。

应用程序必须选择合适大小的报文。

 

UDP 的首部格式

在计算检验和时，临时把“伪首部”和 UDP 用户数据报连接在一起。伪首部仅仅是为了计算检验和。

 

传输控制协议 TCP

TCP 最主要的特点

1.TCP 是面向连接的运输层协议。

2.每一条 TCP 连接只能有两个端点(endpoint)，每一条 TCP 连接只能是点对点的（一对一）。

3.TCP 提供可靠交付的服务。

4.TCP 提供全双工通信。

5.面向字节流。 

 

应当注意

1.TCP 连接是一条虚连接而不是一条真正的物理连接。

2.TCP 对应用进程一次把多长的报文发送到TCP 的缓存中是不关心的。

3.TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）。

4.TCP 可把太长的数据块划分短一些再传送。TCP 也可等待积累有足够多的字节后再构成报文段发送出去。

 

TCP 的连接

1.TCP 把连接作为最基本的抽象。

2.每一条 TCP 连接有两个端点。

3.TCP 连接的端点不是主机，不是主机的IP 地址，不是应用进程，也不是运输层的协议端口。TCP 连接的端点叫做套接字(socket)或插口。端口号拼接到(contatenated with) IP 地址即构成了套接字。  

4.每一条 TCP 连接唯一地被通信两端的两个端点（即两个套接字）所确定。

 

TCP 可靠通信的具体实现

1.TCP 连接的每一端都必须设有两个窗口――一个发送窗口和一个接收窗口。

2.TCP 的可靠传输机制用字节的序号进行控制。TCP 所有的确认都是基于序号而不是基于报文段。

3.TCP 两端的四个窗口经常处于动态变化之中。

4.TCP连接的往返时间 RTT 也不是固定不变的。需要使用特定的算法估算较为合理的重传时间。 

 

TCP 报文段的首部格式

1.源端口和目的端口字段――各占 2 字节。端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现。 

2.序号字段――占 4 字节。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。

3.确认号字段――占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。

4.数据偏移（即首部长度）――占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。“数据偏移”的单位是 32 位字（以 4 字节为计算单位）。 

5.保留字段――占 6 位，保留为今后使用，但目前应置为 0。

6.紧急 URG ―― 当 URG = 1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。

7.确认 ACK ―― 只有当 ACK = 1 时确认号字段才有效。当 ACK = 0 时，确认号无效。

8.推送 PSH (PuSH) ―― 接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。 

9.复位 RST (ReSeT) ―― 当 RST = 1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。

10.同步 SYN ―― 同步 SYN = 1 表示这是一个连接请求或连接接受报文。

11.终止 FIN (FINis) ―― 用来释放一个连接。FIN = 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。

12.窗口字段 ―― 占 2 字节，用来让对方设置发送窗口的依据，单位为字节。

13.检验和 ―― 占 2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。

14.紧急指针字段 ―― 占 16 位，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。  

15.选项字段 ―― 长度可变。TCP 最初只规定了一种选项，即最大报文段长度 MSS。MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。”

16.填充字段 ―― 这是为了使整个首部长度是 4 字节的整数倍。

 

以字节为单位的滑动窗口

根据 B 给出的窗口值

【1】A 构造出自己的发送窗口

【2】A 发送了 11 个字节的数据

P3 C P1 = A 的发送窗口（又称为通知窗口）

P2 C P1 = 已发送但尚未收到确认的字节数

P3 C P2 = 允许发送但尚未发送的字节数（又称为可用窗口）

【3】A 收到新的确认号，发送窗口向前滑动

【4】A 的发送窗口内的序号都已用完，但还没有再收到确认，必须停止发送。

 

发送缓存与接收缓存的作用

发送缓存用来暂时存放：

 1.发送应用程序传送给发送方 TCP 准备发送的数据；

 2.TCP 已发送出但尚未收到确认的数据。

接收缓存用来暂时存放：

 1.按序到达的、但尚未被接收应用程序读取的数据；

 2.不按序到达的数据。

 

需要强调三点

1.A 的发送窗口并不总是和 B 的接收窗口一样大（因为有一定的时间滞后）。

2.TCP 标准没有规定对不按序到达的数据应如何处理。通常是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。

3.TCP 要求接收方必须有累积确认的功能，这样可以减小传输开销。 

 

TCP 的流量控制

流量控制(flow control)就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。利用滑动窗口机制可以很方便地在 TCP 连接上实现流量控制。

 

TCP的拥塞控制

若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏――产生拥塞(congestion)。

 

拥塞控制与流量控制的关系

1.拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。

2.拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。

3.流量控制往往指在给定的发送端和接收端之间的点对点通信量的控制。

4.流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。

 

几种拥塞控制方法

慢开始和拥塞避免

发送方维持一个叫做拥塞窗口 cwnd (congestion window)的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。如再考虑到接收方的接收能力，则发送窗口还可能小于拥塞窗口。

发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。

 

慢开始算法的原理

1.在主机刚刚开始发送报文段时可先设置拥塞窗口 cwnd = 1，即设置为一个最大报文段 MSS 的数值。

2.在每收到一个对新的报文段的确认后，将拥塞窗口加 1，即增加一个 MSS 的数值。

3.用这样的方法逐步增大发送端的拥塞窗口 cwnd，可以使分组注入到网络的速率更加合理。

 

传输轮次(transmission round)

使用慢开始算法后，每经过一个传输轮次，拥塞窗口 cwnd 就加倍。

一个传输轮次所经历的时间其实就是往返时间 RTT。

“传输轮次”更加强调：把拥塞窗口 cwnd 所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。

 

设置慢开始门限状态变量ssthresh

慢开始门限 ssthresh 的用法如下：

当 cwnd < ssthresh 时，使用慢开始算法。

当 cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。

当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。

拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1，而不是加倍，使拥塞窗口 cwnd 按线性规律缓慢增长。

 

当网络出现拥塞时

无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有按时收到确认），就要把慢开始门限 ssthresh 设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。

然后把拥塞窗口 cwnd 重新设置为 1，执行慢开始算法。

这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。

 

慢开始和拥塞避免算法的实现举例

 

乘法减小(multiplicative decrease)

“乘法减小“是指不论在慢开始阶段还是拥塞避免阶段，只要出现一次超时（即出现一次网络拥塞），就把慢开始门限值 ssthresh 设置为当前的拥塞窗口值乘以 0.5。

当网络频繁出现拥塞时，ssthresh 值就下降得很快，以大大减少注入到网络中的分组数。

 

加法增大(additive increase)

“加法增大”是指执行拥塞避免算法后，在收到对所有报文段的确认后（即经过一个往返时间），就把拥塞窗口 cwnd增加一个 MSS 大小，使拥塞窗口缓慢增大，以防止网络过早出现拥塞。

 

必须强调指出

“拥塞避免”并非指完全能够避免了拥塞。利用以上的措施要完全避免网络拥塞还是不可能的。

“拥塞避免”是说在拥塞避免阶段把拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。

 

快重传和快恢复

快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认。这样做可以让发送方及早知道有报文段没有到达接收方。

发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段。

不难看出，快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。

 

快恢复算法

(1) 当发送端收到连续三个重复的确认时，就执行“乘法减小”算法，把慢开始门限 ssthresh 减半。但接下去不执行慢开始算法。

(2)由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，即拥塞窗口 cwnd 现在不设置为 1，而是设置为慢开始门限 ssthresh 减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。

 

从连续收到三个重复的确认转入拥塞避免

发送方的发送窗口的上限值应当取为接收方窗口 rwnd 和拥塞窗口 cwnd 这两个变量中较小的一个。

 

随机早期检测 RED

使路由器的队列维持两个参数，即队列长度最小门限 THmin 和最大门限 THmax。

RED 对每一个到达的数据报都先计算平均队列长度 LAV。

若平均队列长度小于最小门限 THmin，则将新到达的数据报放入队列进行排队。

若平均队列长度超过最大门限 THmax，则将新到达的数据报丢弃。

若平均队列长度在最小门限 THmin 和最大门限THmax 之间，则按照某一概率 p 将新到达的数据报丢弃。

 

TCP 的运输连接管理

运输连接就有三个阶段，即：连接建立、数据传送和连接释放。运输连接的管理就是使运输连接的建立和释放都能正常地进行。

TCP 的连接建立：用三次握手建立 TCP 连接

1.A 的 TCP 向 B 发出连接请求报文段，其首部中的同步位 SYN = 1，并选择序号 seq = x，表明传送数据时的第一个数据字节的序号是 x。

2. B 的 TCP 收到连接请求报文段后，如同意，则发回确认。B 在确认报文段中应使 SYN = 1，使 ACK = 1，其确认号ack = x+1，自己选择的序号 seq = y。

3. A 收到此报文段后向 B 给出确认，其 ACK = 1，确认号 ack = y+1。A 的 TCP 通知上层应用进程，连接已经建立。B 的 TCP 收到主机 A 的确认后，也通知其上层应用进程：TCP 连接已经建立。

 

TCP 的连接释放

1.数据传输结束后，通信的双方都可释放连接。现在 A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的 FIN = 1，其序号seq = u，等待 B 的确认。

2. B 发出确认，确认号 ack = u+1，而这个报文段自己的序号 seq = v。TCP 服务器进程通知高层应用进程。从 A 到 B 这个方向的连接就释放了，TCP 连接处于半关闭状态。B 若发送数据，A 仍要接收。

3. 若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。

4.A 收到连接释放报文段后，必须发出确认。在确认报文段中 ACK = 1，确认号 ack = w ?+1，自己的序号 seq = u + 1。

 

A 必须等待 2MSL 的时间

第一，为了保证 A 发送的最后一个 ACK 报文段能够到达 B。

第二，防止 “已失效的连接请求报文段”出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段，都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。
--------------------- 
作者：Winston_wu 
来源：CSDN 
原文：https://blog.csdn.net/peace_power/article/details/7077067 
版权声明：本文为博主原创文章，转载请附上博文链接！